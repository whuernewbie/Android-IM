#### 用户上线

1. 上线后获取离线消息推送给客户端
2. 同步用户信息到 redis 中

- 操作流程及存在的问题
> 上线事件触发时 
>  
> 先 拿到用户的未读私聊消息(包括好友请求，群聊请求)
>
> 获取用户的所有群聊，拿到 `last_msg_id`，然后将未读的消息取出。同时将 `group_$gid` 群的最大 `mid` 取出存入 redis 中
>
> 然后进行 `mysql_redis` 同步
>
> 问题:
> 
> 在进行 `mysql_redis` 信息同步的过程中，可能会有新的群聊消息出现，这些消息会丢失

> 下线事件触发时
>
> 下线时，先清除 `redis` 信息，保证用户不再接收消息，然后取出用户群聊 `group_$gid` 的所有的最大的 `mid`，作为 `last_msg_id` 存入数据库
>
> 问题:
>
> 在下线时, 在清除 `redis` 信息与 存入 `mysql` 数据的时间段内，可能有新的群消息进入，这时会导致用户会缺失一部分群消息

- 举列来说: 

当用户上线时，对于群号 100，`max(mid)` = 1000,
同时，用户在 群 100 的 `last_msg_id` = 800,
这时我们会取出 801 - 1000 的消息返回给用户，然后将用户信息缓存到 `redis` 中，但是，在从 `mysql` 中取出数据返回给用户的过程中，可能又有新的群聊消息进入，注意这时 `redis` 中还没有用户信息，所以新的群聊消息并不会通知给用户，导致用户这些信息丢失

当用户下线时，对于 群号 100, `max(mid)` = 1000, 当我们操作redis 时，又有新的群消息进入，这时 `max(mid)` = 1005，然后会存入用户和当前群聊的 `last_msg_id` = 1005，实际上理应为 1000，这样当用户再次上线时，会丢掉这 1001-1005 这 5 条消息


### 用户在线时不操作 `last_msg_id`
> 原本的设想是用户上线时，将离线消息推送给好友，然后把 `last_msg_id` 与 `gid` 作为 `uid` 的 `hash` 键
对于一个群来说，每当有新消息，就找到用户对应群号的 `last_msg_id`,进行自增操作，然后在下线时，将 `gid` 对应的 值 存回数据库即可

> 原因在于上线时无法做到一致同步，所以不采取 上述方式
> 
> 即用户在线时间段，不对 `gid` => `last_msg_id` 进行修改，只在用户下线时，获取 `group_$gid` 的最大 `mid` 作为用户的 `last_msg_id` 存入数据库
>
> 这样操作在极端情况下 会造成部分群聊消息丢失 (相对于用户来说)

> CreateGroup  是 http 模块中唯一使用 redis 服务的 api 接口
>
> 当用户创建群聊时 (只有用户在线时才会触发)，需要把群聊消息同步到 用户的 信息中。